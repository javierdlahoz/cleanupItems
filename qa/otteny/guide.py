#to input data from command line -> raw_input()
#&& -> and
#|| -> or
# elseif -> elif
# while relational:
#   statements
#parseInt -> int()
#toString() -> str()
#associative arrays -> dictionaries using {}
#to print only the keys on a dictionary -> dictionary.keys()
#to print only the values on a dictionary -> dictionary.values()
#list -> []
#continue is for start a loop again from the top
#break -> break
#Open a file -> file = open('file', 'w') -- WHERE {w: write, a: append, r: read}
#To write in a file -> file.write()
#To close a file -> file.close()
#To read a line from a file -> file.readline()
#To read all lines in a file -> file.readlines()
#is not empty -> (variable)
#foreach like -> for item in items:
#for like -> for i in range(0, len(items)):
#for with diff increment like -> for i in range(len(items)), increment):
#to get an associative array in foreach -> for keys in items.keys():  print items[key]
#for in a file -> for line in open('filename'):
#comprehension -> items = [item + 1 for item in items]
#lowercase string.lower()
#uppercase string.upper()
#definition of functions -> def function_name(variables):
#return statement return variable
#end of line coding \
#count++ -> count += 1
#calling a function -> function_name(variables)
#booleans -> True and False
#substrings string[init:end] or string[init:]
#asign a new name to a function -> new_name = function_name
#apply a function to every value in a list -> map(function_name, items)
#clone a list -> variable = list(items)
#anonymus function -> variable = lambda parameter : operation
#create a range of numbers -> variable = list(range(init, end))
#filter a list -> filter(function_name, items) / WHEN THE FUNCTION RETURNS TRUE
#Reduce -> need to import functools // functools.reduce(function_name, items)
#modules are like functions grouped in one single file
#import all the functions of a module -> from filename import *
#use a file as a module -> import filename // filename.function()
#rename a module into a file -> import filename as new_name
#defining a class -> class class_name:
#this -> self
#constructor -> def __init__(self):
#instanciate new object -> instance = class_name()
#toString method -> def __str__(self):
#list are declared outside the __init__ method
#array_push -> list.append(value)
#Inheritance -> class Child(Parent):
#method in a Class -> method_name (self, attributes...) // SUPER IMPORTANT!!!
#try - catch -> try: // except:
#try - catch - finally -> finally is to realize some operations after access try or catch -> finally:
#declare new list, dictionaries -> variable = [] // variable = {}